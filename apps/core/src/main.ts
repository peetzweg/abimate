// https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#user-content-creating-and-printing-a-typescript-ast
import * as ts from 'typescript';
import * as path from 'path';
import * as fs from 'fs';
import { Fragment } from './types/Fragment';

function createLiteralFor(value: any) {
  if (value === null) return ts.factory.createNull();

  switch (typeof value) {
    case 'string':
      return ts.factory.createStringLiteral(value);
    case 'boolean':
      return value ? ts.factory.createTrue() : ts.factory.createFalse();
    case 'object':
      if (Array.isArray(value)) {
        return ts.factory.createArrayLiteralExpression(
          value.map((element) => createLiteralFor(element))
        );
      } else {
        return createObjectFromObject(value);
      }
    default:
      return ts.factory.createStringLiteral('not yet implemented');
  }
}

function createObjectFromObject(fragment: object) {
  const properties = Object.entries(fragment).map(([key, value]) => {
    return ts.factory.createPropertyAssignment(key, createLiteralFor(value));
  });
  return ts.factory.createObjectLiteralExpression(properties);
}

function createFragmentDeclaration(
  fragment: Fragment,
  options?: { explicitIdentifier?: boolean }
): [ts.Identifier, ts.ParameterDeclaration] {
  let identifierString = fragment['name'];

  if (!identifierString) {
    throw new Error(
      `Unable to create Identifier for Fragment: ${JSON.stringify(fragment)}`
    );
  }

  if (identifierString && options.explicitIdentifier) {
    identifierString = `${fragment['name']}_${fragment.inputs
      .map((input) => input.type.replace('[]', 'Array'))
      .join('_')}`;
  }

  const identifier = ts.factory.createIdentifier(identifierString);

  const expression = ts.factory.createParameterDeclaration(
    [
      ts.factory.createToken(ts.SyntaxKind.ExportKeyword),
      ts.factory.createToken(ts.SyntaxKind.ConstKeyword),
    ],
    undefined,
    identifier,
    undefined,
    undefined,
    ts.factory.createAsExpression(
      createObjectFromObject(fragment),
      ts.factory.createKeywordTypeNode(ts.SyntaxKind.ConstKeyword as any)
    )
  );

  return [identifier, expression];
}

function createContractFileForAbi(abi: Array<Fragment>): Array<ts.Node> {
  const filteredAbi = abi.filter((fragment) => !!fragment.name);
  const nameCounts = filteredAbi
    .map((fragment) => fragment.name)
    .reduce((acc, cur) => {
      if (acc[cur]) {
        acc[cur] += 1;
      } else {
        acc[cur] = 1;
      }
      return acc;
    }, []);

  const fragmentDeclarationIdentifiers: Array<ts.Identifier> = [];
  const fragmentDeclarations: Array<ts.ParameterDeclaration> = filteredAbi.map(
    (fragment) => {
      const [identifier, declaration] = createFragmentDeclaration(fragment, {
        explicitIdentifier: nameCounts[fragment.name] > 1,
      });
      fragmentDeclarationIdentifiers.push(identifier);
      return declaration;
    }
  );

  if (fragmentDeclarationIdentifiers.length === 0) return [];

  const exportDefault = ts.factory.createExportAssignment(
    [ts.factory.createToken(ts.SyntaxKind.DefaultKeyword)],
    false,
    ts.factory.createAsExpression(
      ts.factory.createArrayLiteralExpression(fragmentDeclarationIdentifiers),
      ts.factory.createKeywordTypeNode(ts.SyntaxKind.ConstKeyword as any)
    )
  );

  return [...fragmentDeclarations, exportDefault];
}

function readABIFromFile(filePath: string) {
  const rawData = fs.readFileSync(filePath, 'utf8');
  const data = JSON.parse(rawData);

  return data['abi']; // TODO expects abi field
}

function convert(
  outputPath: string,
  filePaths: string[],
  options: ts.CompilerOptions
): void {
  if (!fs.existsSync(outputPath)) {
    fs.mkdirSync(outputPath, { recursive: true });
  }

  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });

  for (const filePath of filePaths) {
    const abi = readABIFromFile(filePath);
    if (!abi) {
      console.info(`ABI not found in: ${filePath}`);
      continue;
    }

    try {
      const lineNodes = createContractFileForAbi(abi);

      if (Array.isArray(lineNodes) && lineNodes.length === 0) {
        continue;
      }

      const comment = ts.factory.createJSDocComment(
        'Autogenerated file. Do not edit manually.'
      );
      lineNodes.unshift(comment);

      const fileName = path.basename(filePath, path.extname(filePath));
      const outputFile = `${outputPath}/${fileName}.ts`;
      const fileObj = ts.createSourceFile(
        outputFile,
        '',
        ts.ScriptTarget.ESNext,
        false,
        ts.ScriptKind.TS
      );
      const lineStrings = lineNodes.map((node) =>
        printer.printNode(ts.EmitHint.Unspecified, node, fileObj)
      );
      fs.writeFileSync(outputFile, lineStrings.join('\n'));
    } catch (exception) {
      console.error('Unable to convert:', filePath, exception);
    }
  }
}
if (process.argv.length > 2) {
  convert(process.argv[2], process.argv.slice(3), {
    esModuleInterop: true,
    resolveJsonModule: true,
  });
}
console.log('Done');
